## Event Loops

Modern platforms and runtimes typically rely on many underlying system layers to operate. For example, there’s an underlying file system, a database system, and other web services that may be relied on by a given language implementation, library, or framework. Interaction with these components typically involves a period where we’re doing nothing but waiting for the response. This can be a very large waste of computing resources.

对于很多现代系统而言, 发送请求后等待会消耗大量计算资源。这种做法是非常不明智的。

JavaScript is a single threaded asynchronous runtime. Now, conventionally async programming is generally associated with multi-threading, but we’re not allowed to create new threads in JavaScript. Instead, asynchronicity in JavaScript is achieved using an event-loop mechanism.

为了实现异步编程模型, 往往采用多线程的模式。但是在JavaScript中是不允许多线程的, 所以JavaScript使用event-loop机制来实现异步执行框架。

JavaScript has historically been used to interact with the DOM and user interactions in the browser, and thus an event-driven programming model was a natural fit for the language. This has scaled up surprisingly well in high throughput scenarios in Node.js.

因为JavaScript多应用在网页交互中, 所以event-driven(事件驱动)模型非常适合它。

The general idea behind event-driven programming model is that the logic flow control is determined by the order in which events are processed. This is underpinned by a mechanism which is constantly listening for events and fires a callback when it is detected. This is the JavaScript’s event loop in a nutshell.

A typical JavaScript engine has a few basic components. They are :

一个典型的JavaScript引擎有如下一些基础组件:

* Heap Used to allocate memory for objects
* Stack Function call frames go into a stack from where they’re picked up from top to be executed.
* Queue A message queue holds the messages to be processed.


* 堆区: 为对象分配内存。
* 函数栈: 函数调用栈存放所有需要被执行的函数,自底而上存放。
* 消息队列: 消息队列维持所有要被消费的消息。


Each message has a callback function which is fired when the message is processed. These messages can be generated by user actions like button clicks or scrolling, or by actions like HTTP requests, request to a database to fetch records or reading/writing to a file.


每个消息都会指定一个回调函数, 用于指定当消息被处理的时候需要执行的逻辑。消息可以通过用户行为产生: 例如按钮点击, 或者鼠标的滑动, 甚至http请求, 数据库请求等。


Separating when a message is queued from when it is executed means the single thread doesn’t have to wait for an action to complete before moving on to another. We attach a callback to the action we want to do, and when the time comes, the callback is run with the result of our action. Callbacks work good in isolation, but they force us into a continuation passing style of execution, what is otherwise known as Callback hell.


把消息执行和消息排队分离，可以有效解决单线程执行阻塞的问题。我们给消息配置一个回调函数, 当消息被执行的时候会触发回调函数的执行。回调函数的执行虽然是独立的, 但是迫使我们用连续处理的方式去构建它, 这就是经常提到的回调地狱问题(Callback hell)。

```
getData = function(param, callback){
  $.get('http://example.com/get/'+param,
    function(responseText){
      callback(responseText);
    });
}

getData(0, function(a){
  getData(a, function(b){
    getData(b, function(c){
      getData(c, function(d){
        getData(d, function(e){
         // ...
        });
      });
    });
  });
});


```

**VS**


```

getData = function(param, callback){
  return new Promise(function(resolve, reject) {
    $.get('http://example.com/get/'+param,
    function(responseText){
      resolve(responseText);
    });
  });
}

getData(0).then(getData)
  .then(getData)
  .then(getData)
  .then(getData);

```


Promises are an abstraction which make working with async operations in JavaScript much more fun. Callbacks lead to inversion of control, which is difficult to reason about at scale. Moving on from a continuation passing style, where you specify what needs to be done once the action is done, the callee simply returns a Promise object. This inverts the chain of responsibility, as now the caller is responsible for handling the result of the promise when it is settled.


Promises是处理异步操作很好的抽象, 由于回调导致了控制反转所以在调用深度上难以控制。相比而言, 通过简单返回promise对象实现异步能力显得更加合理。

The ES2015 spec specifies that “promises must not fire their resolution/rejection function on the same turn of the event loop that they are created on.” This is an important property because it ensures deterministic order of execution. Also, once a promise is fulfilled or failed, the promise’s value MUST not be changed. This ensures that a promise cannot be resolved more than once.


ES2015标准定义了这样一条规则: ""。 这个规则是非常重要的, 因为它保证了确定性的执行顺序。一旦一个promise完成了或者失败了, promise的值就不能被改变了, 这个保证了一个promise不会被触发执行多次。



Let’s take an example to understand the promise resolution workflow as it happens inside the JavaScript Engine.


下面通过一个示例解释JavaScript引擎中 promise的工作流过程。


Suppose we execute a function, here g() which in turn, calls another function f(). Function f returns a promise, which, after counting down for 1000 ms, resolves the promise with a single value, true. Once f gets resolved, a value true or false is alerted based on the value of the promise.


假设执行一个函数, 如图所示在函数g()中调用函数f()。函数f()返回一个Promise对象, 1000毫秒之后设置promise为true。执行alert(true)还是alert(false)依据返回的promise的值。


![图1](https://raw.githubusercontent.com/EOSToolKitCN/Workflow-Design/master/images/sector1/eventloop/eventloop-1.png)


Now, JavaScript’s runtime is single threaded. This statement is true, and not true. The thread which executes the user code is single threaded. It executes what is on top of the stack, runs it to completion, and then moves onto what is next on the stack. But, there are also a number of helper threads which handle things like network or timer/settimeout type events. This timing thread handles the counter for setTimeout.


目前JavaScript的运行时是单线程的, 运行代码的执行线程也是单线程的, 会从栈顶开始依次执行到栈底。但是还是会有一些辅助线程处理网络/时间等类型的事件。如下图的时间线程处理setTimeout的函数逻辑。


![图2](https://raw.githubusercontent.com/EOSToolKitCN/Workflow-Design/master/images/sector1/eventloop/eventloop-2.png)


Once the timer expires, the timer thread puts a message on the message queue. The queued up messages are then handled by the event loop. The event loop as described above, is simply an infinite loop which checks if a message is ready to be processed, picks it up and puts it on the stack for it’s callback to be executed.


一旦时间过期, timer线程会在消息队列上放一个消息。排队消息随后会被事件循环处理掉。事件循环如上所述: 是一个无限循环检测的装置, 用于一直检测队列中的消息是否满足被执行的条件, 如果满足就把它们放进函数栈中等待被执行。


![图3](https://raw.githubusercontent.com/EOSToolKitCN/Workflow-Design/master/images/sector1/eventloop/eventloop-3.png)


Here, since the future is resolved with a value of true, we are alerted with a value true when the callback is picked up for execution.

所以, 一旦future被至为true, 接下来的回调函数alert将会执行。


![图4](https://raw.githubusercontent.com/EOSToolKitCN/Workflow-Design/master/images/sector1/eventloop/eventloop-4.png)


We’ve ignored the heap here, but all the functions, variables and callbacks are stored on heap. As we’ve seen here, even though JavaScript is said to be single threaded, there are number of helper threads to help main thread do things like timeout, UI, network operations, file operations etc.

我们在上面的描述中忽略了堆, 事实上所有的函数, 变量, 回调都存储在堆上。尽管JavaScript号称是单线程工作的, 但事实上有很多辅助线程在帮助它完成超时, UI, 网络, 文件等操作。


Run-to-completion helps us reason about the code in a nice way. Whenever a function starts, it needs to finish before yielding the main thread. The data it accesses cannot be modified by someone else. This also means every function needs to finish in a reasonable amount of time, otherwise the program seems hung. This makes JavaScript well suited for I/O tasks which are queued up and then picked up when finished, but not for data processing intensive tasks which generally take long time to finish.

一直运行到完成帮助我们解释了一种良好的代码运行方式。一旦一个函数开始执行, 它必须自行完之后才释放主线程。在此期间函数运行中涉及的变量不会其他线程改变。这就要求每一个函数都需要在规定时间内完成, 否则程序就完全被挂起了。所以JavaScript非常适合I/O型任务, 放入队列然后被触发执行结束。但是并不适合海量数据处理等耗时非常长的任务。


We haven’t talked about error handling, but it gets handled the same exact way, with the error callback being called with the error object the promise is rejected with.

上述我们还没有讨论错误是怎么被处理的, 它也是相同的方式。当关联的promise设置值为错误处理对象, 则处理错误的回调被调起。



Event loops have proven to be surprisingly performant. When network servers are designed around multithreading, as soon as you end up with a few hundred concurrent connections, the CPU spends so much of its time task switching that you start to lose overall performance. Switching from one thread to another has overhead which can add up significantly at scale. Apache used to choke even as low as a few hundred concurrent users when using a thread per connection while Node.js can scale up to a 100,000 concurrent connections based on event loops and asynchronous IO.


 

